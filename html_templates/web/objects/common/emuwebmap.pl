#!/usr/bin/perl

#
#  Copyright (c) 1998-2012 KE Software Pty Ltd
#

### emuwebmap.cgi
use strict;
# CVS Stuff
# $Revision: 1.11 $
# $Date: 2012-02-08 05:20:55 $

my $DEBUG=0;

############################################################
use lib '/home/emu/webnew/web';
# change script personality here
$perl::Tools::confFile = '../config.mapper.php';             
$perl::Tools::WEBMAPRELEASE = '3-1-1.5-emu';
############################################################

use CGI::Carp qw (fatalsToBrowser);
use perl::Tools;

# we must have the following options in the conf file
%perl::Tools::requiredOptions = (
		CGIURL	=> 'scalar',
		COMPRESSION	=> 'scalar',
		CONF_DESCRIPTION=> 'scalar',
		CONFRELEASE	=> 'scalar',
		CLEAN_INTERVAL	=> 'scalar',
		DISKFREE	=> 'scalar',
		EMUCLIENT	=> 'scalar',
		EMU_CAT_TAX	=> 'array',
		ENVIRONMENT	=> 'scalar',
		HELP_PAGE	=> 'scalar',
		HOST		=> 'scalar',
		IPADDRESS	=> 'scalar',
		JAVASCRIPT	=> 'scalar',
		LATLONGEXTENT	=> 'scalar',
		LEGEND_TEMPLATE	=> 'scalar',
		LINK_LIST	=> 'scalar',
		LINK_TEMPLATE	=> 'scalar',
		LOGFILE 	=> 'scalar',
		MAPDISPLAY_HTML	=> 'scalar',
		MAP_TEMPLATE	=> 'scalar',
		MAPSERVER	=> 'scalar',
		MAPSERVERURL	=> 'scalar',
		MAPSIZE 	=> 'scalar',
		MAX_SHAPEFILES  => 'scalar',
		MINFREE		=> 'scalar',
		MSG_HTML	=> 'scalar',
		OUT_OF_ORDER_HTML 	=> 'scalar',
		PORTAL_URL	=> 'scalar',
		QUERY_HEADER_HTML => 'scalar',
		QUERY_FOOTER_HTML => 'scalar',
		RECORD_DISPLAY_HTML => 'scalar',
		REFERENCE_IMAGE => 'scalar',
		REFERENCELATLONGEXTENT	=> 'scalar',
		REFMAPSIZE 	=> 'scalar',
		RTREE_BUILD 	=> 'scalar',
		RTREE_QUERY 	=> 'scalar',
		SEARCH_PAGE	=> 'scalar',
		SHAPE 		=> 'array',
		SPATIAL_QUERY_HTML => 'scalar',
		STYLEFILE	=> 'scalar',
		SYMBOL		=> 'array',
		SYMBOLSIZE	=> 'scalar',
		STOPFILE	=> 'scalar',
		SYSTEMNAME	=> 'scalar',
		SHOWCONF	=> 'scalar',
		TIMEOUT		=> 'scalar',
		TEMPDIR		=> 'scalar',
		TEMPURL		=> 'scalar',
		TEXSHAPER	=> 'scalar',
		TEXXMLSERVICE => 'scalar', 
		UNZIP		=> 'scalar',
		URL_XML 	=> 'array',
		URL_DIGIR 	=> 'array',
		XML_CUSTOM_IMAGE => 'scalar',
		XML_CUSTOM_TRANSLATE => 'array',
		XML_CUSTOM_RECORD => 'scalar',
		XML_CUSTOM_RECORD_BLOCK => 'scalar',
		XML_CUSTOM_ROOT => 'scalar', 
		XML_CUSTOM_SUMMARY_ELEMENTS => 	'scalar',
		XML_CUSTOM_THUMBNAIL => 'scalar',
		XMLDISPLAY_HTML	=> 'scalar',
		XSLTPROC	=> 'scalar',
		ZIP	=> 'scalar',
	);

@perl::Tools::filesThatMustExist = qw(
		MAPDISPLAY_HTML
		MAPSERVER
		MSG_HTML
		OUT_OF_ORDER_HTML
		QUERY_HEADER_HTML
		QUERY_FOOTER_HTML
		REFERENCE_IMAGE 
		SPATIAL_QUERY_HTML
		TEMPDIR
		XMLDISPLAY_HTML
		ZIP
	);


###################################################
# Global variables (tsk tsk tsk)
# NONE !
###################################################

# declare some subroutines
sub ConfigurationReport();
sub CheckMapserverOutput($$);
sub DefFile($$%);
sub DisplayFile($$$);
sub MakeDisplayFile($$$$);
sub MakeDefFile($$$%);
sub ModifyMapFile($);
sub ModifyDisplayFile();
sub ValidQueryTerms(%);

###################### START HERE ###############################

perl::Tools::Initialisation();




#create a unique id number for anything generated by this session
my $uniqueName = time() . "_$$";

my $HTTP_REFERER = $ENV{HTTP_REFERER};
$HTTP_REFERER = $param{RETURNURL} if ($param{RETURNURL});

# OK - find out how called and act accordingly

my $DEBUG = 0;
$DEBUG = 1 if  ($param{DEBUGOPTIONS} =~ /args/);

# experimental stuff to use java applet box drawing
#MakePolygonAdjustments() if ($param{KEBOX});

if ($ENV{PATH_INFO} =~ /\/clean$/i)
{
	# erase all cache entries
	perl::Tools::BlastCache();
}

if  ( $ENV{PATH_INFO} =~ /^configure/i or 
	($conf{COMMANDLINE} and ! exists $param{PUSH}))
{
	# asked for configuration OR script run from command line 

	if ($conf{SHOWCONF} or (! exists$ENV{PATH_INFO}))
	{
		print "Content-type: text/plain\n\n<pre>";
		print ConfigurationReport();
	}
	else
	{
		Error("System Called Invalidly");
	}
}
elsif  ((exists $param{DEBUGOPTIONS}) and $param{DEBUGOPTIONS} and $param{DEBUGOPTIONS} !~ /none/i)
{

	if  ($param{DEBUGOPTIONS} =~ /env/)
	{
		print "Content-type: text/plain\n\n<pre>";
		print "Request for System Environment\n\n";

		perl::Tools::ShowSystemEnvironment();
		perl::Tools::ShowCGIParams();
	
		exit 0;
	}
	elsif  ($param{DEBUGOPTIONS} =~ /params/)
	{
		print "Content-type: text/plain\n\<pre>n";
		print "Request for passed CGI Params\n\n";
	
		perl::Tools::ShowCGIParams();
		perl::Tools::ShowSystemEnvironment();
	
		exit 0;
	}
	elsif  ($param{DEBUGOPTIONS} =~ /urls/)
	{
		# user wants a list of urls to be called
		my ($used,$notUsed) = perl::Tools::MakeUrls($param{QUERYRESTRICT},$param{URL});
	
		print "Content-type: text/plain\n\n<pre>";
		print "Request for URLS that will be called\n\n";
		print "---------------------------------------------\n";
		print "URL Calling...\n";
		print "---------------------------------------------\n";
		print "Will Call:\n",join "\n",@$used; 
		print "\n\nCould Call:\n",join "\n",@$notUsed; 
	
		perl::Tools::ShowCGIParams();
		perl::Tools::ShowSystemEnvironment();
	
		print ConfigurationReport();
		exit 0;
	}
	elsif  ($param{DEBUGOPTIONS} =~ /clean/)
	{
		print "Content-type: text/plain\n\n<pre>";
		print "Request to clean cache made\n\n";
		print "Files in cache before clean: ",perl::Tools::CountCache(),"\n";
		perl::Tools::BlastCache();
		print "Files in cache after clean: ",perl::Tools::CountCache(),"\n";
		print "<a >Go Back</a>\n";
		exit 0;
	}
	  elsif  ($param{DEBUGOPTIONS} =~ /installcheck/)
	{
		print "Content-type: text/html\n\n<pre>";
		print "Request to check installation and setup\n\n";
		perl::Tools::InstallCheck();
		print "</pre>\n";
		exit 0;
	}
	else 
	{
		print "Content-type: text/plain\n\n<pre>";
 		print "Request for '$param{DEBUGOPTIONS}'\n\n";
		print ConfigurationReport();
	}
}
elsif (exists $param{'ACTION'})
{


	if ($param{ACTION} =~ /spatialquery/i and $param{DISPLAY} =~ /rawdata/i)
	{
		# we have been requested to do a spatial query
		my $xmldata = perl::Tools::QueryDataSources(%param);	
		print "Content-type: text/html\n\n";
		print(perl::Tools::DisplayXML($xmldata));
		exit 0;
	}
	elsif ($param{ACTION} =~ /query/i)
	{
		# we have been told to get data to map (ie we have not been
		# called from existing map)
		if (ValidQueryTerms(%param) or $param{PUSH} or $param{ACTION} =~ /spatialquery/i)
		{
			#
			# get xml data then
			# generate argument string for mapserver (involves also creating the
			# display html page and the mapserver map file)
			# then print map
			#

			my $xmldata = perl::Tools::QueryDataSources(%param);	

			# uncomment next line for testing/debugging (saves xml of all
			# data combined)
			# perl::Tools::SendToFile('',$xmldata,"webmap.xml.$$");
	
	
			my $cgistring = GenerateMapserverArgs($xmldata,%param);
	
			MakeQueryPages($uniqueName);
	
			# make html display page using mapserver
			my ($elapsed,$page) = MapServerWrapper($cgistring);
	
			print $page;
		}
		else
		{
			print perl::Tools::Message((
			'Search Failed',
			'Unable to Conduct Search',
			'You must enter at least a family,genus or species ',
			'If you do not know a Search to use, try: <b>genus=Felis</b>',
			'(feral cat = Felis catus)'));
		}

	}
	elsif ($param{MODE} =~ /browse/i)
	{
		# here if map display has already been drawn at least once


		$CGIstring = AdjustRequest($CGIstring,\%param);  # eg  avoid panning over edge etc

		# draw map

		ModifyDisplayFile(); 
		if ($CGIstring =~ /map=([^&]+)&/)
		{
			my $defFile = $1;
			while($defFile =~ s/%([\dA-Fa-f][\dA-Fa-f])/chr(hex($1))/ge){};
			ModifyMapFile(perl::Tools::EntityDecode($defFile));
		}
		
		my ($elapsed,$page) = MapServerWrapper($CGIstring);

		print $page;

	}

	elsif ($param{ACTION} =~ /pointinfo/i)
	{
		# a request for data on a point - no mapping involved - need to
		# extract required data and display


		my ($datafile,$recno) = split /\s+/,$param{RECORD};
		my $displayRecordPage = DisplayLinkPage($datafile,$recno);
		perl::Tools::BrowserDisplay($displayRecordPage);

	}
	elsif ($param{ACTION} =~ /link/i)
	{
		# a request for linkages to a name in the legend
		# 

		perl::Tools::BrowserDisplay(generalLinksPage($param{CLASSNAME},$param{SHOWBY}));
	}
	elsif ($param{ACTION} =~ /digir/i)
	{
		# a request for data from a digir data source
		# 
		print "Content-type: text/plain\n\n";
		perl::Tools::BrowserDisplay(
			perl::Tools::DigirSearch($param{ENDPOINT},
				$param{RESOURCE},
				$param{FILTER},
				$param{START},
				$param{NUMBER})
		);
	}
	else
	{
		# no idea what to do...

		perl::Tools::Debug(1,"Unconstructed Action = $param{ACTION}",%param);
		Error("Not Constructed yet");
	}
}
else
{
	# no idea what to do...

	perl::Tools::Debug(1,"No Action for session=$uniqueName",%param);
	Error("System Called Invalidly");
}	

# do the housework

perl::Tools::Hoover(0,%conf);


################### END HERE ################################
sub ValidQueryTerms(%)
{
	my %params = @_;

	foreach my $param (keys %param)
	{
		if ($param =~ /QUERY_TERM_(.+)/ and $param !~ /START$|COUNT$/)
		{
			return 1 if (length $param{$param});
		}
	}
	if (exists $param{QUERY_TERM})
	{
		return $param{QUERY_TERM} =~ /GENUS|SPECIES|FAMILY|IRN/i;
	}

	return 0;
}

sub RefXy2ImgXy($$)
{
	# function to convert reference xy point to image xy point
	my ($refx,$refy) = @_;

	# get lat long of reference xy
	my ($refXpixels,$refYpixels) = split /\s+/,$conf{REFMAPSIZE};
	my ($refleft,$refbottom,$refright,$reftop) = split /\s+/,$conf{REFERENCELATLONGEXTENT};
	my $long = $refleft + (($refright - $refleft) * $refx / $refXpixels); 
	my $lat = $reftop - (($reftop - $refbottom) * $refy / $refYpixels);

	my ($xpixels,$ypixels) = split /\s+/,$conf{MAPSIZE};
	my ($left,$bottom,$right,$top) =split /\s+/,$param{IMGEXT};

	my $x = ($long - $left) * $xpixels / ($right - $left);
	my $y = ($top - $lat) * $ypixels / ($top - $bottom);

	# mapserv has restriction on size of parameters...
	# to up this change #define MS_MAXIMGSIZE in map.h
	# in mapserv source.  number below = 2*MS_MAXIMGSIZE
	$x = 8192 if ($x > 8192);
	$x = -8192 if ($x < -8192);
	$y = 8192 if ($y > 8192);
	$y = -8192 if ($y < -8192);
	return (int $x,int $y);
}
sub ImgXy2MapXy($$)
{
	# function to convert xy img point (ie pixels) to Map xy (ie dec. deg.)
	
	my ($x,$y) = @_;

	# get lat long of xy
	my ($Xpixels,$Ypixels) = split /\s+/,$conf{MAPSIZE};
	my ($left,$bottom,$right,$top) = split /\s+/,$param{IMGEXT};
	my $long = $left + (($right - $left) * $x / $Xpixels); 
	my $lat = $top - (($top - $bottom) * $y / $Ypixels);
	return ($long,$lat);
}

sub MakePolygonAdjustments()
{
	# experimental stuff to use java applet box drawing
	# it takes passed polygon information and adjusts the
	# cgi string and other parameters to make mapper act on a polygon
	# rather than a single point click

	# pretend click was in centre of box
	my ($minx,$miny,$maxx,$maxy) = split /\s+/,$param{KEBOX};
	$param{'IMG.X'} = int($minx + ($maxx - $minx) / 2);
	$param{'IMG.Y'} = int($miny + ($maxy - $miny) / 2);
	$CGIstring .= "&img.x=$param{'IMG.X'}&img.y=$param{'IMG.Y'}";

	# if zoom in and a box, work out magnification based on box
	if ($param{'ZOOMDIR'} < 0 and ($maxx - $minx) and ($maxy - $miny))
	{
		my ($xpixels,$ypixels) = split /\s+/,$conf{MAPSIZE};
		my $xfactor = $xpixels/($maxx - $minx);
		my $yfactor = $ypixels/($maxy - $miny);
		my $factor = $yfactor;
		$factor = $xfactor if ($xfactor < $yfactor);

		$param{ZOOMSIZE} = $factor;	
		$CGIstring =~ s/zoomsize=[0-9]+/zoomsize=$param{'ZOOMSIZE'}/;
			
	}
	elsif ($param{'ZOOMDIR'} =~ /q/i)
	{
		$CGIstring =~ s/(^|&)mode=[A-Za-z]+/$1mode=nquery/;
		$CGIstring =~ s/(^|&)zoomdir=[A-Za-z]+/$1zoomdir=0/;
		my ($lat,$long) = ImgXy2MapXy($minx,$miny);
		$CGIstring .= "&minx=$lat&miny=$long";
		($lat,$long) = ImgXy2MapXy($maxx,$maxy);
		$CGIstring .= "&maxx=$lat&maxy=$long";
		$CGIstring .= "&imgbox=$minx+$miny+$maxx+$maxy";
	}
	elsif ($param{'ZOOMDIR'} =~ /z/i)
	{

		my ($latmin,$longmin) = ImgXy2MapXy($minx,$miny);
		my ($latmax,$longmax) = ImgXy2MapXy($maxx,$maxy);
		push my @points,$latmin,$longmin,$latmin,$longmax,$latmax,$longmax,$latmax,$longmin;
		print MakePolygonQueryPage(@points);
		exit 0;
	}
}

sub AdjustRequest($)
{
	# modifies parameters passed to mapserv via cgi string to prevent
	# panning outside bounds and to allow zoom, pan and query to work
	# properly (we have a modified interface to the standard mapserver
	# method that allows us to do pan/zoom/query using a single html
	# control element)

	my ($CGIstring) = @_;


	# where was clicked (if anywhere)
	my ($xpixels,$ypixels) = split /\s+/,$conf{MAPSIZE};
	my ($refXpixels,$refYpixels) = split /\s+/,$conf{REFMAPSIZE};
	if (exists $param{'REF.X'})
	{
		# user clicked reference image not main map
		my ($xclick,$yclick) = ($param{'REF.X'},$param{'REF.Y'});
		($param{'IMG.X'},$param{'IMG.Y'}) = RefXy2ImgXy($xclick,$yclick);
		$CGIstring =~ s/ref\.x=[0-9]+/img.x=$param{'IMG.X'}/;
		$CGIstring =~ s/ref\.y=[0-9]+/img.y=$param{'IMG.Y'}/;
	}


	# adjust behaviour depending on radio button selection (zoom/pan/query)
	if ($param{'ZOOMDIR'} =~ /q/i)
	{
		# if query radio button pushed set mode as nquery
		# this enables one set of radio buttons to select
		# zoom/pan or query ( a bit trickier to do using just 
		# standard mapserv)
		$CGIstring =~ s/(^|&)mode=[A-Za-z]+/$1mode=nquery/;
		$CGIstring =~ s/(^|&)zoomsize=\d+//;
		#$CGIstring =~ s/(^|&)zoomdir=[A-Za-z]+/$1searchmap=true&zoomdir=1&zoomsize=2/;
		$CGIstring =~ s/(^|&)zoomdir=[A-Za-z]+/$1zoomdir=0/;
		$CGIstring =~ s/imgxy=&//;
	}
	elsif ($param{'ZOOMDIR'} =~ /z/i)
	{
		# if zap radio button pushed set mode as coordinate
		$CGIstring =~ s/mode=[A-Za-z]+/mode=coordinate/;
		$CGIstring =~ s/zoomdir=[A-Za-z]+/zoomdir=0/;
	}
	elsif ($param{'ZOOMDIR'} =~ /\d/)
	{
		if ($param{ZOOMDIR} < 0  and ($param{KEMAG} / $param{ZOOMSIZE}) < 1 )
		{
			# attempt to zoom out beyond 1:1
			$param{ZOOMSIZE} = $param{KEMAG};
			$CGIstring =~ s/zoomsize=[0-9]+/zoomsize=$param{'ZOOMSIZE'}/;
		}
		
		$param{'KEMAG'} *= $param{'ZOOMSIZE'} if $param{'ZOOMDIR'} > 0;
		$param{'KEMAG'} /= $param{'ZOOMSIZE'} if $param{'ZOOMDIR'} < 0;
		$CGIstring =~ s/kemag=[0-9.]+/kemag=$param{'KEMAG'}/;
	
	}
	elsif ($param{'REDRAW'} =~ /redraw/i)
	{
			# if redraw button pushed - force it to be a
			# browse mode even if mode was query
			$CGIstring =~ s/mode=[A-Za-z]+/mode=browse/;
			$CGIstring =~ s/zoomdir=[A-Za-z0-1\-]+/zoomdir=0/;
			$param{'ZOOMDIR'} = 0;
			$param{'MODE'} = 'browse';

			if (exists $param{IMGXY})
			{
				my ($imgx,$imgy) = split /\s/,$param{IMGXY};
				$CGIstring .= "&img.x=$imgx";
				$CGIstring .= "&img.y=$imgy";
			}
	}

	# avoid panning over edge (otherwise we get truncated map which looks
	# ugly - pretend instead we didn't click that close to edge... (DO NOT
	# DO for Queries or there will be tears !)
	
	if ($param{ZOOMDIR} !~ /q/i)
	{

		my ($xclick,$yclick) = ($param{'IMG.X'},$param{'IMG.Y'});

		my ($left,$bottom,$right,$top) =split /\s+/,$param{IMGEXT};


	#my ($mapCentreLat,$mapCentreLong) = 
		#(($bottom+$top)/2,($right+$left)/2);

		my $longClick = $left + (($xclick * ($right - $left)) / $xpixels);
		my $latClick = $top - (($yclick * ($top - $bottom)) / $ypixels);
		my $minlongClick = -180 + (360/($param{KEMAG}*2));
		my $maxlongClick = 180 - (360/($param{KEMAG}*2));
		my $minlatClick = -90 + (180/($param{KEMAG}*2));
		my $maxlatClick = 90 - (180/($param{KEMAG}*2));


		my $longpanError = 0;
		if ($longClick < $minlongClick)
		{
			$longClick = $minlongClick;
			$longpanError++;
		}
		elsif ($longClick > $maxlongClick)
		{
			$longClick = $maxlongClick;
			$longpanError++;
		}
		$xclick = $xpixels * ($longClick - $left) / ($right - $left) if $longpanError;
	
		my $latpanError = 0;
		if ($latClick < $minlatClick)
		{
			$latClick = $minlatClick;
			$latpanError++;
		}
		elsif ($latClick > $maxlatClick)
		{
			$latClick = $maxlatClick;
			$latpanError++;
		}
		$yclick = $ypixels * ($top - $latClick) / ($top - $bottom) if $latpanError;
	

		if ($latpanError or $longpanError)
		{
			$param{'IMG.X'} = $xclick;
			$param{'IMG.Y'} = $yclick;
		}	
		
		$CGIstring =~ s/(^|&)img\.x=[0-9]+/$1img.x=$param{'IMG.X'}/;
		$CGIstring =~ s/(^|&)img\.y=[0-9]+/$1img.y=$param{'IMG.Y'}/;
	}	
my ($long,$lat) = ImgXy2MapXy($param{'IMG.X'},$param{'IMG.Y'});
#Error("$lat~$long~$param{'IMG.X'}~$param{'IMG.Y'}") if ($param{'ZOOMDIR'} =~ /q/i);
#Error("$lat~$long~$param{'IMG.X'}~$param{'IMG.Y'}");
#$CGIstring =~ s/mode=[A-Za-z]+/mode=coordinate/;
#Error($CGIstring);		

	return $CGIstring;
}	

sub MakeDisplayFile($$$$)
{
	# generates the map display html page

	my ($xmldata,$dispFile,$name,$msg) = @_;

	my $count = perl::Tools::CountRecords($xmldata);
	my %messages = perl::Tools::ExtractMessages($xmldata);
	my @msg;
	foreach my $who (sort keys %messages)
	{
		if ($messages{$who} =~ /Error/)
		{
			$messages{$who} = "<span class=\"error\">$messages{$who}</span>";
		}
		push @msg, "$who: $messages{$who}" if $messages{$who} !~ /records OK/;
	}
	push @msg,$msg if $msg;
	my $messages = join "<br />",@msg;

	my $disp = DisplayFile($count,$messages,$name);

	$dispFile = $dispFile."/display.".$name.".html";
	open F , ">$dispFile" 
		or perl::Tools::Error("Could not open display template : $dispFile : $!");
	print F $disp;
	close F;
	return $dispFile;
}

sub MakeDefFile($$$%)
{

	# makes the map file and query header/footers

	my ($dispFile,$mapdef,$name,%haveLatLong) = @_;


	my $defn = DefFile($dispFile,$name,%haveLatLong);


	my $queryHeaderFile = "$conf{TEMPDIR}/$name.queryheader.html";
	my $queryFooterFile = "$conf{TEMPDIR}/$name.queryfooter.html";
	$defn =~ s/\[QUERY_HEADER\]/$queryHeaderFile/gi;
	$defn =~ s/\[QUERY_FOOTER\]/$queryFooterFile/gi;

	# get any map definitions we need
	$param{SCALE} = EstimateScale($defn) if ! exists $param{SCALE};
	$defn .= "#scale originally set to $param{SCALE}";

	open F , ">$mapdef" 
		or perl::Tools::Error("Could not open map definition file: $mapdef : $!");
	print F $defn;
	close F;

	
}

sub ModifyMapFile($)
{
	# given a mapserver map file, do any lastminute dirty modifications to it
	my ($mapfile) = @_;
	if (-e $mapfile)
	{
 		open F , "$mapfile" or perl::Tools::Error("Could not open map definition file: $mapfile : $!");
		my $def = join '',<F>;
		close F;	
		if ($param{ZOOMDIR} =~ /q/i)
		{
			$def =~ s/^(\s*)(.+)(\s+#MACRO\s+normal\((.+)\)\s+alternate\((.+)\))/$1$5$3/gm;
		}
		else
		{
			$def =~ s/^(\s*)(.+)(\s+#MACRO\s+normal\((.+)\)\s+alternate\((.+)\))/$1$4$3/gm;
		}

 		open F , ">$mapfile" or perl::Tools::Error("Could not open map definition file: $mapfile : $!");
		print F $def;
		close F;	
	}
	else
	{
		perl::Tools::Error("Map file: $mapfile does not exit");
	}
}

sub ModifyDisplayFile()
{
	my $name = $param{HTMLPAGE_ID};

	# determine scale (if possible)
	if (exists $param{SCALE} and $param{SCALE})
	{
		if ($param{ZOOMDIR} > 0)
		{
			$param{SCALE} /= $param{ZOOMSIZE}
		}
		elsif ($param{ZOOMDIR} < 0)
		{
			$param{SCALE} *= $param{ZOOMSIZE}
		}
	}	
	else
	{
		perl::Tools::Debug(1,"no scale",%param);
	}

	# get default template page
	$param{SEARCHMESSAGES} =~ s/\\+//g;
	my $disp = DisplayFile($param{SPECIMENCOUNT},$param{SEARCHMESSAGES},$name);


	my $dispFile = $conf{TEMPDIR}."/display.$name.html";
	open F , ">$dispFile" 
		or perl::Tools::Error("Could not open display template : $dispFile : $!");
	print F $disp;
	close F;
}

sub GenerateMapserverArgs($%)
{
	my ($xmldata,%param) = @_;

	my $showby = $param{SHOWBY};

	my $elapsed = time();
	my %group = perl::Tools::XMLGrouped($xmldata,"$showby",'record');

	my $groups = scalar keys %group;
	if ($groups > $conf{MAX_SHAPEFILES})
	{
		my @groups = sort keys %group;
		while (scalar keys %group > $conf{MAX_SHAPEFILES})
		{
			delete $group{shift @groups};
		}
	}

	#
	# make 'live' shapefiles from xml data
	#

	my $i = 0;
	my @layers;
	my %nolatlong;	
	my %haveLatLong;	
	my @bounds = (181,91,-181,-91); # will contain bounding lat/longs
					# format:
					# longmin,latmin,longmax,latmax

	my @msgs = ();
	my $totalWithLats = 0;
	my $totalWithoutLats = 0;
	foreach my $group (sort keys %group)
	{
 		# name may have multiple lines - remove them
 		$group =~ s/\n/ /gs;

		my $fileNamePrefix = "s${uniqueName}_$i";
		my ($latRef,$dataRef,$nolatlong,@groupBounds) = 
			perl::Tools::XMLFlatten($group{$group},$fileNamePrefix,0);

		# keep count of how many recs have no lat/long and how many do
		my $with = scalar(@$latRef);
		my $total = $with + $nolatlong;
		$totalWithLats += $with;
		$totalWithoutLats += $nolatlong;

  		# name may have term tag added by data portal if query term
		(my $cleanGroup = $group) =~ s/<\/{0,1}term>//sg;
		$nolatlong{$cleanGroup} += $nolatlong;	
		$haveLatLong{$cleanGroup} = $with;	

		$cleanGroup =~ s/:/ /g;
		if ($with)
		{
			push @msgs,"<tr class='small' style='color:#ff0000;'><td>$cleanGroup</td><td align='center'>$with/$total</td></tr>"; 
		}
		else
		{
			push @msgs,"<tr class='small'><td>$cleanGroup</td><td align='center'>$with/$total</td></tr>"; 
			$groups--;
		}

		if (@$latRef)
		{
			# make a query string suitable for firing at data portal
			# for records in this shapefile

			my $queryString = CreateQueryString($group,$group{$group});
			#my $queryString = CreateQueryString($param{SHOWBY},$group{$group});

			my ($filename,$description) = 
				perl::Tools::MakeAShapeFile($group,$param{SHOWBY},
					$fileNamePrefix, $latRef,$dataRef, $queryString);
			# add live shape as a layer parameter	
			(my $cleanDescription = $description) =~ s/<\/{0,1}term>//sg;
			push @layers,"layer=". lc $cleanDescription;

			$bounds[0] = $groupBounds[0] if ($groupBounds[0] < $bounds[0]);
			$bounds[1] = $groupBounds[1] if ($groupBounds[1] < $bounds[1]);
			$bounds[2] = $groupBounds[2] if ($groupBounds[2] > $bounds[2]);
			$bounds[3] = $groupBounds[3] if ($groupBounds[3] > $bounds[3]);
		}
		$i++;
	}
	$elapsed = time() - $elapsed;

	my $total = $totalWithLats + $totalWithoutLats;
	unshift @msgs,"<table class='small' style='color:#336699'
		border='0'><tr class='small'><th align='left'>Specimens</th><th>With Coordinates/Total
		Matches</th></tr><tr class='small'><td>Total</td><td
		align='center'>$totalWithLats/$total</td></tr>"; 

	unshift @msgs,"<tr><td colspan='2'><hr/></td></tr>";
	push @msgs,"<tr class='small'><td colspan='2'><hr/></td></tr>";
	push @msgs,"<tr class='small'><td colspan='2' style='color:ff0000;'>Maximum of $conf{MAX_SHAPEFILES}
		Data/Geographic Layers.<br/>  $groups potential Data/Geographic Layers requested.<br/>  
		Some requested Data Layers may not be shown.</td></tr>"
		if ($groups > $conf{MAX_SHAPEFILES});
	push @msgs,"</table>";


	#foreach my $layer (keys %nolatlong)
	#{
		#push @msgs, "$layer: <span class=\"error\">No Lat/Long: $nolatlong{$layer}</span>"
				#if ($nolatlong{$layer});
	#}

	#push @msgs,"<span class=\"ignoreMe\">(xml manipulation + shapefile creation: $elapsed secs)</span>";


	my $msgs = join "\n",@msgs;

	#
	# make the html display page and
	# make the mapserver 'map' file (NB needs 'live' shapefiles to exist
	# at this point otherwise they won't appear on map)
	#


	my $dispFile = "$conf{TEMPDIR}/display.$uniqueName.html";

	my $mapdef="$conf{TEMPDIR}/$uniqueName.map";

	# adjust map display if necessary - set map to cover all data points
	if ($bounds[0] < 180)
	{
		my (@defaultBounds) = split /\s+/,$conf{LATLONGEXTENT},-1;
		$defaultBounds[0] = $bounds[0] if ($bounds[0] < $defaultBounds[0]);
		$defaultBounds[1] = $bounds[1] if ($bounds[1] < $defaultBounds[1]);
		$defaultBounds[2] = $bounds[2] if ($bounds[2] > $defaultBounds[2]);
		$defaultBounds[3] = $bounds[3] if ($bounds[3] > $defaultBounds[3]);

		# add a little bit around edges
		my $extra = 5;
		$defaultBounds[0] -= $extra if $defaultBounds[0] > -180 + $extra;
		$defaultBounds[1] -= $extra if $defaultBounds[1] > -90 + $extra;
		$defaultBounds[2] += $extra if $defaultBounds[2] < 180 - $extra;
		$defaultBounds[3] += $extra if $defaultBounds[3] < 90 - $extra;

		$conf{LATLONGEXTENT} = join ' ',@defaultBounds;
	}

	MakeDefFile($dispFile,$mapdef,$uniqueName,%haveLatLong);
	MakeDisplayFile($xmldata,$conf{TEMPDIR},$uniqueName,$msgs);
	
	#
	# set the static shapefile layers on or off as requested in conf file
	# then make a CGI parameter list to pass to mapserver
	#

	my $i=1;
	foreach my $shape (@{$conf{SHAPES}})
	{
		my ($name,$data,$type,$minscale,$maxscale,
			$colour,$on,$querymap,$other,$notes) 
			= split /,/,$shape,10;
		$name = lc $name;
		push @layers, "layer=$name" if ($on =~ /on|yes/i);
		$i++;
	}
	my $layers = join '&',@layers;

	if (! $param{KEMAG})
	{
		my ($left,$bottom,$right,$top) =split /\s+/,$conf{LATLONGEXTENT};
		my @displayAspect = split /\s+/,$conf{MAPSIZE};
		my $displayAspect = $displayAspect[0]/$displayAspect[1];
		my $wantedAspect = ($right-$left)/($top-$bottom);

		if (($wantedAspect/$displayAspect) > 1)
		{
			$param{KEMAG} = 360/($top-$bottom);
		}
		else
		{
			$param{KEMAG} = 360/($right-$left);
		}

	}	
	return "map=$mapdef&$layers&zoomsize=2&zoomdir=0&kemag=$param{KEMAG}&htmlpage_id=$uniqueName";
}	

sub MapServerWrapper($)
{
	my ($cgistring) = @_;
	$cgistring =~ s/\//%2F/g;

	if ($cgistring =~ /imgext=(.*?&)/)
	{

		# sometimes mapserver does not return valid header
		# this seems to occur when doing a query AND having
		# a querymap in the map file AND querying a SINGLE point...
		# I do not know why (but but I think its a gd lib issue -
		# images become too big.  It also core dumps. 
		# By resetting the mapext parameter to imgextent it seems to
		# avoid the problem
		my $imgext = $1;
		$cgistring =~ s/mapext=.*?&/mapext=$imgext/;
	}	

	if ($cgistring !~ /scale=/)
	{
		$cgistring .= '&scale=' . $param{SCALE};
		if ($cgistring !~ /mapxy=/)
		{
			my ($left,$bottom,$right,$top) =split /\s+/,$conf{LATLONGEXTENT};
			my $x = $left + ($right - $left)/2;
			my $y = $bottom + ($top - $bottom)/2;
			$cgistring .= "&mapxy=$x+$y";
		}	
	}
	$cgistring =~ s/\s+&$//g;

	$ENV{'CONTENT_TYPE'} = "application/x-www-form-urlencoded";
	$ENV{'REQUEST_METHOD'} = "POST";
	$ENV{'CONTENT_LENGTH'} =  length($cgistring);

	# experimental
	#my @usersessions = `find /proc -name 'file' -exec ls -l {} \\; | grep mapserv`;
	#my $usersessions = 1 + scalar @usersessions ;

	my $usersessions = 'not available';


	my $elapsed = time();

	# Say "Helloo mapserv !"

	my $map  = `echo '$cgistring' | $conf{MAPSERVER}` ;
	
	if ($map =~ /^Content-type: text\/html\s+(<!--.+?-->)/is)
	{
		my $mapComment = $1;
		my $docType = '';#'<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
		           	#"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
		            	#<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">';

		$map =~ s/$mapComment\s+<html>/$docType\n$mapComment/is;
	}
	$elapsed = time() - $elapsed;;

	$map =~ s/\[MAPSERVER_ELAPSED_TIME\]/(image generation: $elapsed secs)<br \/><span class="ignoreMe">Current Users: $usersessions<\/span>/g;
	$map =~ s/\[zoomsize_$param{ZOOMSIZE}_select\]/selected='1'/g;
	$map =~ s/\[zoomsize_\d+_select\]//g;
	return ($elapsed,CheckMapserverOutput($map,$cgistring));
}

sub CheckMapserverOutput($$)
{
	my ($map,$cgistring) = @_;
 	if ( $map =~ /ms[^\s]+() *:/)
	{
		# hmmm... we got a mapserver error message back - not good
		$map =~ s/.*?://s;
		my @additional;
		my $heading;
		if ($map =~ /unable to access file/i)
		{
			$heading ="Mapserver Returned the following Error"; 
			push @additional,$map;
			push @additional,'Cache may have have expired -
				Try doing your search again';
			push @additional,"Click <a href='$conf{SEARCH_PAGE}'>HERE</a>
					to return to Search Page";
		}
		elsif ($map =~ /Search returned no results/i)
		{
			$heading ="Query Failed - <br/>Search Returned No Results"; 
			push @additional,'Possibly you were not exactly on the point';
			push @additional,'Accurate Selection can be difficult 
				at Large Scales'; 
			push @additional,"Often 'Zooming In' makes selection
				easier and more accurate"; 
		}
		elsif ($map =~ /Too many layers/i)
		{
			$heading ="The following error was reported - $map"; 
			push @additional,'Possibly you are attempting to map too many species';
			push @additional,'Retry with fewer species';
		}
		 else
		{
			$heading ="Mapserver Returned returned an Error";
			push @additional,$map;
			push @additional,"Please Report This Fault";
		}
		$map = perl::Tools::Message($heading, @additional);
	}
	elsif ($map !~ /^Content-type/)
	{
		# hmmm... mapserver did not return valid header
		perl::Tools::Error ("MapServer subsystem failed~".
				   "Mapserver did not return valid Content-Type Header~".
		                   "Please Report this to Fault~$map~$cgistring");
	}
	#elsif ($map !~ /INPUT=PNG/)
	#{
		#perl::Tools::Error ("MapServer binary anomoly~".
				   #"Mapserver binary not configured to use png images as output~".
				   #"Mapserver binary needs to be reconfigured and rebuilt~".
		                   #"Please Report this to Fault~(mapserver error string: $map)");
	#}
	#elsif ($map !~ /INPUT=GDAL/)
	#{
		#perl::Tools::Error ("MapServer binary anomoly~".
				   #"Mapserver binary not configured to use gdal as input~".
				   #"Mapserver binary needs to be reconfigured and rebuilt~".
		                   #"Please Report this to Fault~(mapserver error string: $map)");
	#}
	elsif ($map =~ /<HEAD><TITLE>MapServer Message<\/TITLE><\/HEAD>(.*)/si)
	{
		# mapserver returned a message...
		my $error = $1;
		$cgistring =~ s/mode=[A-Za-z]+/mode=browse/;

		$map =~ s/<body(.*?)>/<body bgcolor='7f7f7f'><h1>Error Detected: $error<\/h1>/i;
		# DANGER WILL ROBINSON !! infinite recursion mode enabled !
		#return $map . MapServerWrapper($cgistring);
	}
	else
	{
		# assume we are here because we got a correct html page
		# from mapserver
	

		# Extract Scale if Possible (mapserver will have placed value in
		# page wherever a '[scale]' string appears (This bit clunky but
		# cannot get scale info any other way - I think)
	
		if ($map =~ /<!--\s+SCALE\s*=\s*([0-9.]+)\s+-->/)
		{
			my $scale = $1;
			$map =~ s/\[SCALE\]//g; 
			#$map =~ s/\[SCALE\]/<span class='tiny'>scale 1:$scale (est: $param{SCALE})<\/span>/g; 
		}


		
	}
	$map .= "<hr><h1>DEBUG</h1>".ShowEnvironment($cgistring,%param) if $DEBUG;
	return $map;
}	

sub DisplayFile($$$)
{
	# reads MAPDISPLAY_HTML template file, substitues a few variables
	# and returns result (which should be valid html)

	my ($count,$messages,$name) = @_;

	# make check box for each live data shapefile
	my (@liveshapes,@keywords);
	my (@layers,@title);
	foreach my $datafile (GrabLiveShapes($name))
	{
		my $name = $datafile;
		$name =~ s/\.shp//;
		my ($session,$filename,$description,$category,$portalLink) 
			= perl::Tools::ReadInfoFile($name);

		my $lcdescription = lc $description;
		$description =~ s/:/ /g;
		$description = "<i>$description</i>";
		push @title,$description;
		push @layers,
      			"<span class='available'>\n".
			"  <input type='checkbox' name='layer[]' ".
			"value='$lcdescription' \[${lcdescription}_check\] />\n".
			"$description</span>";
		push @liveshapes,$description;	
		push @keywords,$lcdescription;	
	}
	@liveshapes = sort @liveshapes;
	my $liveshapes = join ', ',@liveshapes;
	my $keywords = join '~',@keywords;

	#my ($left,$bottom,$right,$top) =split /\s+/,$conf{LATLONGEXTENT};
	#$param{KEMAG} = 360/($right-$left) if (! exists $param{KEMAG} or ! $param{KEMAG});
	if ((! exists $param{KEMAG}) or (! $param{KEMAG}))
	{
		my ($left,$bottom,$right,$top) =split /\s+/,$conf{LATLONGEXTENT};
		my @displayAspect = split /\s+/,$conf{MAPSIZE};
		my $displayAspect = $displayAspect[0]/$displayAspect[1];
		my $wantedAspect = ($right-$left)/($top-$bottom);

		if (($wantedAspect/$displayAspect) > 1)
		{
			$param{KEMAG} = 360/($top-$bottom);
		}
		else
		{
			$param{KEMAG} = 360/($right-$left);
		}

	}	
	my $mag = sprintf "%4.2f",$param{KEMAG};
	$mag =~ s/\.00//;

	my $title = join ',',@title;
	$title =~ s/<.+?>//g;
	$title = "${mag}X ".$title;

	# make check box for each static shapefile
	my (@off,@invisible,@on);
	my $scale = $param{SCALE};
	my $note=1;
	my @notes;
	my %notes;
	foreach my $shape (@{$conf{SHAPES}})
	{
		my ($name,$data,$type,$minscale,$maxscale,$colour,$on,$query,$other,$notes) = 
			split /,/,$shape,10;
		my $lcname = lc $name;

		$maxscale = 999999999 if ! $maxscale;
      		my $layerstring = " <input type='checkbox' name='layer[]' ".
			"   value='$lcname' \[${lcname}_check\] />$name";
		if ($notes)
		{
			if (! exists $notes{$notes})
			{
				$notes{$notes} = $note;
				push @notes,"$note : $notes";
				$note++;
			}
			$layerstring .= " <span class='superscript'>$notes{$notes}</span>" ;
		}	
		if ($scale < $minscale)
		{
			$layerstring = "<span class='notAvailable'>".
			  "$layerstring not visible at this scale (need to zoom out)</span>\n";
			push @invisible,$layerstring;  
		}
		elsif ($scale > $maxscale)
		{
			$layerstring = "<span class='notAvailable'>".
			  "$layerstring not visible at this scale (need to zoom in)</span>\n";
			push @invisible,$layerstring;  
		}
		elsif (0)
		{
		}
		else
		{
			$layerstring = "<span class='inuse'>$layerstring</span>\n";
			push @on,$layerstring;  
		}
	}
	
	my @available = (@on,@off);
	my $availableCount = scalar  @available;
	my $offCount = scalar  @off;
	my $invisibleCount = scalar  @invisible;
	my $onCount = scalar  @on;
	my $layersCount = scalar  @layers;
	my $OFF = join "<br />\n",@off;
	my $INVISIBLE = join "<br />\n",@invisible;
	my $ON = join "<br />\n",@on;
	my $AVAILABLE = join "<br />\n",@available;
	@layers = sort @layers;
	my $LAYERS = join "<br />\n",@layers;

	my $shapeNotes = join "<br />\n",@notes;

	# add some hidden html parameters for later reference
	my @hidden;
	my $hiddenMessages = perl::Tools::Encode($messages,1);
	push @hidden,"<input type='hidden' name='specimencount' value='$count' />";
	push @hidden,"<input type='hidden' name='searchmessages' value='$hiddenMessages' />";
	push @hidden,"<input type='hidden' name='htmlpage_id' value='$name' />";
	push @hidden,"<input type='hidden' name='PREVIOUSURL' value='$conf{SEARCH_PAGE}' />";
	push @hidden,"<input type='hidden' name='title' value='$title' />";
	push @hidden,"<input type='hidden' name='history_depth' value='$conf{HISTORY_DEPTH}' />";
	push @hidden,"<input type='hidden' name='query_terms' value='$param{QUERY_TERM}' />";
	push @hidden,"<input type='hidden' name='query_terms_keywords' value='$keywords' />";
	my $hidden = join "\n",@hidden;
	
	my $mapMode = 'PAN';
	if ($param{ZOOMDIR} == 0)
	{
		$mapMode = 'PAN';
	}
	elsif ($param{ZOOMDIR} =~ /Q/i)
	{
		$mapMode = 'QUERY';
	}
	elsif ($param{ZOOMDIR} =~ /Z/i)
	{
		$mapMode = 'ZAP';
	}
	elsif ($param{ZOOMDIR} > 0)
	{
		$mapMode = 'ZOOMIN';
	}
	elsif ($param{ZOOMDIR} < 0)
	{
		$mapMode = 'ZOOMOUT';
	}
	my ($mapx,$mapy) = split /\s+/, $conf{MAPSIZE};
	my $mapsize = "height='$mapy' width='$mapx'";

	my $file = perl::Tools::ReadTemplate($conf{MAPDISPLAY_HTML},"Display Page Template");

	my $clean = sprintf "%3.1f",$conf{CLEAN_INTERVAL} / 60;

	my $firstmap = "&nbsp;";
	$firstmap = "<a href='javascript:history.go(-$conf{HISTORY_DEPTH});'>" .
		"First Map</a>" if $conf{HISTORY_DEPTH};
	my $gohome = "javascript:history.go(-" . ($conf{HISTORY_DEPTH} +1) .");";
	
	$file =~ s/\[STYLE\]/$conf{STYLE}/i;

	$file =~ s/\[SYSTEMNAME\]/$conf{SYSTEMNAME}/gi;
	$file =~ s/\[TITLE\]/$title/i;
	$file =~ s/\[SESSION\]/$uniqueName/gi;
	$file =~ s/\[CGIURL\]/$conf{CGIURL}/i;
	$file =~ s/\[MAPSERVERURL\]/$conf{MAPSERVERURL}/i;
	$file =~ s/\[HEADING\]/$liveshapes/i;
	$file =~ s/\[TOTAL\]/$count/gi;

	$file =~ s/\[LAYERS_COUNT\]/$layersCount/i;
	$file =~ s/\[LAYERS_OFF_COUNT\]/$offCount/i;
	$file =~ s/\[LAYERS_INVISIBLE_COUNT\]/$invisibleCount/i;
	$file =~ s/\[LAYERS_ON_COUNT\]/$onCount/i;
	$file =~ s/\[LAYERS\]/$LAYERS/i;
	$file =~ s/\[LAYERS_OFF\]/$OFF/i;
	$file =~ s/\[LAYERS_INVISIBLE\]/$INVISIBLE/i;
	$file =~ s/\[LAYERS_ON\]/$ON/i;
	$file =~ s/\[LAYERS_AVAILABLE_COUNT\]/$availableCount/i;
	$file =~ s/\[LAYERS_AVAILABLE\]/$AVAILABLE/i;

	$file =~ s/\[SUMMARY\]/$messages/gi;
	$file =~ s/\[IMGXY\]/$param{IMGXY}/i;
	$file =~ s/\[IMGX\]/$param{'IMG.X'}/i;
	$file =~ s/\[IMGY\]/$param{'IMG.Y'}/i;
	$file =~ s/\[HIDDEN\]/$hidden/i;
	$file =~ s/\[FIRSTMAP\]/$firstmap/gi;
	$file =~ s/\[GOHOME\]/$gohome/gi;
	$file =~ s/\[RETURNURL\]/$conf{SEARCH_PAGE}/gi;
	$file =~ s/\[HELPURL\]/$conf{HELP_PAGE}/gi;
	$param{LEGEND} = 'Specimens' if (! $param{LEGENDHEADING});
	$file =~ s/\[LEGENDHEADING\]/$param{LEGEND}/i;
	$file =~ s/\[SCRIPTS\]/$conf{JAVASCRIPT}/i;
	$file =~ s/\[RELEASE\]/$perl::Tools::WEBMAPRELEASE/ig;
	$file =~ s/\[MAPMODE\]/$mapMode/gi;
	$file =~ s/\[MAPSIZE\]/$mapsize/i;
	$file =~ s/\[NOTES\]/$shapeNotes/i;
	$file =~ s/\[DEBUG\]//i;
	$file =~ s/\[CLEAN_INTERVAL_MINS\]/$clean/ig;
	$file =~ s/\[HOST\]/$conf{HOST}/ig;
	#$file =~ s/\[.+?]//g;


	return  $file;
}

sub CreateQueryString($$)
{
	# make a query string that'll hit the data portal
	# used typically from Legend - eg click on legend entry and hit something
	# that gives data on entries with that name (say back to portal or
	# php taxonomy etc)

	my ($terms,$xml) = @_;
	my @cgi;
	my @terms;
	my @urls;
	my @others;

	foreach my $term (split /,/,$terms)
	{
		if ($xml =~ /<$term>(.*?)<\/$term/si)
		{
			my $data = $1;
			if ($data)
			{
				if ($term =~ /class|order|family|genus|species|subspecies|irn|name/i)
				{
					push @terms,	'<QUERY_TERM_' . 
						uc ($term) . 
						"0>$data</QUERY_TERM_" . 
						uc ($term) .'0>' ;
				}
				elsif ($term =~ /dataSource|source|ke_source/i)
				{
					push @urls,"<dataSource>$data</dataSource>";
				}
				else
				{
					push @others,"$term=$data";
				}
			}
		}	
	}
	if (@terms)
	{
		push @cgi,'query_term='. join ('',@terms);
	}
	else
	{
		push @cgi,'query_term='. $param{QUERY_TERM};
	}
	if (@urls)
	{
		push @cgi,'URL='. join ('',@urls);
	}
	else
	{
		push @cgi,'URL=' .$param{URL};
	}
	if (@others)
	{
		push @cgi,@others;
	}
	#push @cgi,'xsl=xsl/html.goog.xss,kePortalData,html,pagingOK';


	# if passed a portal URL with parameters - dodgy it up
	if ($conf{PORTAL_URL} =~ /\?/)
	{
		my $portal = $conf{PORTAL_URL};

		foreach my $arg (@cgi)
		{
			my ($param,$val) = split /=/,$arg;
 			$val =~ s/^\s*|\s*$//g;
 			$val =~ s/ /+/g;
 			$portal =~ s/\[$param\]/$val/ig;
 			$portal =~ s/\[QUERY_TERM_$param\]/$val/ig;
		}
		foreach my $arg (@terms)
		{
			if ($arg =~ /<(.+?)>\s*(.+)\s*<\/.+>/s)
			{
				my $param = $1;
				my $val = $2;
				$val =~ s/<\/{0,1}term>//g; # if highlight match then need to remove tags
				$portal =~ s/\[$param\]/$val/ig;
			}
		}
		# if url still has unfilled slots - try any parameters
		if ($portal =~ /\[.+\]/)
		{
			foreach my $param (keys %param)
			{
				$portal =~ s/\[$param\]/$param{$param}/ig;
			}
		}


		# if url still has unfilled slots - try any conf parameters
		# (allows us to use default parameters in conf file if values
		# not passed by cgi process)
		if ($portal =~ /\[.+\]/)
		{
			foreach my $param (keys %perl::Tools::requiredOptions)
			{
				if ($perl::Tools::requiredOptions{$param} eq 'scalar')
				{
					$portal =~ s/\[$param\]/$conf{$param}/ig;
				}
			}
		}
		# finally look form parameter [NAME]
		(my $name = $terms) =~ s/:/ /g;
		$portal =~ s/\[NAME\]/$name/;

		$portal =~ s/\[.+?\]//g;
		$portal =~ s/\s+/+/g;
		return $portal
	}
	my $cgiCache = perl::Tools::StoreCGIArguments(join '&',@cgi);
	return $conf{PORTAL_URL} . "?action=query&cgiParamCacheName=$cgiCache";
}	

sub GrabLiveShapes($)
{
	#get species info shapefile names
	my $name = $_[0];

	my @datafiles  = glob "$conf{TEMPDIR}/s${name}_*.shp";
	return @datafiles;
}

sub GetDataOnRecord($$)
{
	my ($datafile,$recno) = @_;

	my $actualFilename = $datafile;
	if (! -e $datafile)
	{
		$actualFilename .= '._z' if $conf{COMPRESSION};
		$actualFilename = $conf{TEMPDIR} .'/' . $actualFilename;
	}	

	if ( -e $actualFilename)
	{
		my @data = perl::Tools::ReadFromFile($datafile);
		my @records = split /(?=<record )|(?=<record>)/s,join '',@data;
		shift @records if ($records[0] !~ /^\s*<record/s);

		my $record = $records[$recno-1];

		if ($record)
		{
			$record =~ s/(<\/record>).*$/$1/s;
			return ($record,0);
		}
		else
		{
			return (0,
			perl::Tools::Message(
				"Request for data failed.",
				"Wanted recno=$recno/".scalar @records,
				"in $actualFilename",
				"system fault"));
		}
	}
	else
	{
		return(0,perl::Tools::Message("Request for data failed.",
		"Cache has expired",
		"Sorry you will need to redo search",
		"(missing file '$datafile')"));
	}
}	

sub MakePolygonQueryPage($$$$)
{ 
	my @polygonPoints = @_;

	Error("No points specified in polygon") if (! @polygonPoints);
	Error("Incorrect number of points in polygon".
		"~missing longitude for a point~" . join '~',@polygonPoints) 
			if (@polygonPoints % 2);

	push my @queryTerms, "<table>\n";
	foreach my $queryTerm (split /~/,$param{QUERY_TERMS_KEYWORDS},-1)
	{
		$queryTerm =~ s/:/ /s;
		if ($queryTerm)
		{
			push @queryTerms,"<tr>\n<td>$queryTerm</td>\n</tr>";
		}	
	}
	my $queryTerms = join "\n",@queryTerms;
	$queryTerms .= "</table>\n";

	push my @polygonInputs,"<table>\n<tr>\n<td>Latitude </td><td> Longitude</td>";
	my $j = 0;
	for (my $i=0; $i < (@polygonPoints/2); $i++)
	{
		push @polygonInputs,"<td><input type='text' name='query_term_polygon_long$i' value='$polygonPoints[$j]' />".
				"</td><td>".
				"<input type='text' name='query_term_polygon_lat$i' value='$polygonPoints[$j+1]' /></td>";
		$j += 2;
	}

	my $polygonInputs = join "\n</tr><tr>\n",@polygonInputs;
	$polygonInputs .= "</tr>\n</table>\n";


	my $file = perl::Tools::ReadTemplate($conf{SPATIAL_QUERY_HTML},"spatial query page");

	my $CLEAN_INTERVAL_MINS = $conf{CLEAN_INTERVAL} / 60;
	$file =~ s/\[STYLE\]/$conf{STYLE}/i;
	$file =~ s/\[SYSTEMNAME\]/$conf{SYSTEMNAME}/ig;
	$file =~ s/\[CONFIGURATION\]/$conf{CONF_DESCRIPTION}/i;
	$file =~ s/\[CLEAN_INTERVAL_MINS\]/$CLEAN_INTERVAL_MINS/ig;
	$file =~ s/\[RELEASE\]/$perl::Tools::WEBMAPRELEASE/i;
	$file =~ s/\[POLYGON\]/$polygonInputs/i;
	$file =~ s/\[PREVIOUS_TERMS]/$queryTerms/i;
	$file =~ s/\[HIDDEN\]//i;
	$file =~ s/\[CGIURL\]/$conf{CGIURL}/gi;
	return  "Content-type: text/html\n\n".$file;
}

sub MakeQueryPages($)
{
	my ($name) = @_;

	my $title = 'Point';

	my $queryHeaderPage = "$conf{TEMPDIR}/$name.queryheader.html";
	my $queryFooterPage = "$conf{TEMPDIR}/$name.queryfooter.html";

	my $queryHeader 
		= perl::Tools::ReadTemplate($conf{QUERY_HEADER_HTML},'Query Header Template');
	my $queryFooter 
		= perl::Tools::ReadTemplate($conf{QUERY_FOOTER_HTML},'Query Footer Template');

	# make any adjustments to query header html...
	my $gohome = "javascript:history.go(-" . ($conf{HISTORY_DEPTH} +1) .");";

	my $cgistring = "$conf{MAPSERVERURL}?map=[map]&queryfile=[map][id].qy&mode=map&imgsize=200+200[get_layers]";

	$queryHeader =~ s/\[TITLE\]/$param{TITLE}/i;
	$queryHeader =~ s/\[STYLE\]/$conf{STYLE}/i;
	$queryHeader =~ s/\[SYSTEMNAME\]/$conf{SYSTEMNAME}/gi;
	$queryHeader =~ s/\[MAPSERVERURL\]/$conf{MAPSERVERURL}/gi;
	$queryHeader =~ s/\[CGIURL\]/$conf{CGIURL}/gi;
	$queryHeader =~ s/\[RETURNURL\]/$conf{SEARCH_PAGE}/gi;
	$queryHeader =~ s/\[GOHOME\]/$gohome/gi;
	$queryHeader =~ s/\[REFIMAGE\]/$cgistring/i;


	open F,">$queryHeaderPage" or Error("Cannot Write to $queryHeaderPage: $!\n");
	print F $queryHeader;
	close F;

	open F,">$queryFooterPage" or Error("Cannot Write to $queryFooterPage: $!\n");
	print F $queryFooter;
	close F;

	return ($queryHeaderPage, $queryFooterPage);

}

sub EstimateScale
{
	# given map definition file, estimate (intial) scale of image

	my $factor = 314982288; # was calculated by trial & error

	my ($file) = @_;
	my ($scale,$x,$y,$xmin,$ymin,$xmax,$ymax) = (0,0,0,0,0,0,0);
	if ($file =~ /EXTENT\s+([0-9.-]+)\s+([0-9.-]+)\s+([0-9.-]+)\s+([0-9.-]+)/)
	{
		($xmin,$ymin,$xmax,$ymax) = ($1,$2,$3,$4);
	}
	if ($file =~ /SIZE\s+([0-9.-]+)\s+([0-9.-]+)/)
	{
		($x,$y) = ($1,$2);
	}

	my ($scaley,$scalex) = (0,0);
	$scaley = $factor * ($ymax-$ymin)/$y if $y;
	$scalex = $factor * ($xmax-$xmin)/$x if $x;

	if ($scaley > $scalex)
	{
		return $scaley;
	}

	return $scalex;
}

sub MakeLegendFile()
{
	$conf{LEGEND_TEMPLATE} =~ s/\[EMUCLIENT\]/$conf{EMUCLIENT}/g
		if $conf{LEGEND_TEMPLATE} =~ /EMUCLIENT/;
	my $legend = perl::Tools::ReadTemplate($conf{LEGEND_TEMPLATE},"Legend Template");
	$legend =~ s/\[CGIURL\]/$conf{CGIURL}/ig;
	$legend =~ s/\[SHOWBY\]/$param{SHOWBY}/ig;
	#$legend =~ s/\[LINKHEAD\]/<a href='http:\/\/www.google.com\/search?q=/;
	#$legend =~ s/\[LINKMID\]/'>/;
	#$legend =~ s/\[LINKTAIL\]/<\/a>/;
	my $legendFile = "$conf{TEMPDIR}/legend.$uniqueName.html";
	open F,">$legendFile" or Error("Cannot Write to $legendFile: $!\n");
	print F $legend;
	close F;
	return $legendFile;
}

sub ReadDefaultMapTemplate
{
	# if not provided as a configurable file then use this for the
	# mapserver template file skeleton
	my $symbolset = 'symbols/symbols.sym';
	my $legend = 'html/legend.html';

	if ($conf{ENVIRONMENT} =~ /emu/i)
	{
		$symbolset = '../objects/images/symbols.sym';
		$legend = 'html/[EMUCLIENT]/legend.html';
	}
	return <<MAPTEMPLATE;

EXTENT [EXTENT]
SIZE [SIZE]

units dd
SHAPEPATH "[MAPBITS]/maps"
#FONTSET "[MAPBITS]/conf/font.list"
FONTSET "/dev/null"
#SYMBOLSET "[MAPBITS]/conf/symbols.sym"
SYMBOLSET "[MAPBITS]/$symbolset"
STATUS on

WEB
	TEMPLATE "[DISPFILE]"
	IMAGEPATH "[TEMPDIR]/"
	IMAGEURL "[TEMPURL]/"
	HEADER "[QUERY_HEADER]"
	FOOTER "[QUERY_FOOTER]"
	LOG "[TEMPDIR]/mapserv-emuwebmap.log"
END


SCALEBAR
  	IMAGECOLOR 255 255 255
  	LABEL
    		COLOR  127 127 127
    		SIZE medium    
  	END

	POSITION lc
	POSTLABELCACHE true
	OUTLINECOLOR 255 255 255
  	STYLE 1
  	SIZE 500 10
  	COLOR 127 127 127
  	UNITS KILOMETERS
  	INTERVALS 4
  	TRANSPARENT TRUE
  	STATUS on
END

QUERYMAP
	COLOR 255 0 0
	SIZE [SIZE]
	STYLE HILITE
	STATUS on
END

LEGEND
	STATUS ON
	KEYSIZE 18 12
	LABEL
		TYPE BITMAP
		SIZE MEDIUM
		COLOR 0 0 90
	END	
	TEMPLATE [LEGEND_TEMPLATE]
	#TEMPLATE [MAPBITS]/$legend
	#IMAGECOLOR 51 102 153
	#OUTLINECOLOR 255 255 255
END

REFERENCE
	IMAGE [REFERENCEIMAGE]
	EXTENT [REFERENCEEXTENT] 
	SIZE 256 128
	STATUS ON
	COLOR -1 -1 -1
	OUTLINECOLOR 255 0 0
END
 
SYMBOL
    Name 'querySymbol'
    Type VECTOR
    Filled True
    Points
        0 0
        1 0
        1 1
        0 1
        0 0
    END
  END


#-----------------------------------------------------------------------------
[LAYERS]
#-----------------------------------------------------------------------------

END # end of map file
MAPTEMPLATE

}

sub DefFile($$%)
{
	# reads MAP_TEMPLATE template file, substitues a few variables
	# and returns result (which should be valid mapserver map file)

	my ($displayFile,$uniqueName,%haveLatLong) = @_;

	my $legendFile = MakeLegendFile();
	

	# create LAYER directives based on conf file settings
	# NB these are NOT the species data layers - they get done
	# further down
	my @layers;
	foreach my $shape (@{$conf{SHAPES}})
	{
		my ($name,$data,$type,$minscale,$maxscale,$colour,$on,$query,$other,$notes) 
				= split /,/,$shape,10;

		# set up query components
		my $querymap = '';
		if ($query =~ /yes/i)
		{
			my $fn = "$INSTALLDIR/html/$conf{EMUCLIENT}/${data}_header.html";
			$querymap .= 	"\n   # missing  header $fn\n" if (! -e $fn);
			$querymap .= 	"\n   HEADER $fn\n" if (-e $fn);

			$fn = "$INSTALLDIR/html/$conf{EMUCLIENT}/${data}_footer.html";
			$querymap .= 	"\n   # missing footer $fn\n" if (! -e $fn);
			$querymap .= 	"\n   FOOTER $fn\n" if (-e $fn);

			$fn = "$INSTALLDIR/html/$conf{EMUCLIENT}/${data}.html";
			$querymap .= 	"\n   # missing query template $fn\n" if (! -e $fn);
			$querymap .= 	"\n   TEMPLATE $fn\n"   if (-e $fn);
		}

		# set colours
		$colour = 	"\n   CLASS\n".
				"      COLOR $colour\n".
    				"   END" if $colour;

		# set min/max scale value
		$minscale = "\n   MINSCALE $minscale" if $minscale;
		$maxscale = "\n   MAXSCALE $maxscale" if $maxscale;

		# make a layer directive
		$name = lc $name;
		if ($other =~ /^tiled/i)
		{
			push @layers,
				"LAYER\n".
				"   NAME \"$name\"\n".
				"   # $notes\n".
    				"   STATUS $on\n".
    				"   TILEINDEX '$data'\n".
    				"   TILEITEM 'Location'\n".
    				"   TYPE  $type\n".
				$minscale .
				$maxscale .
				$querymap.
				"\nEND # end of $name layer object\n";
		}
		elsif ($other =~ /ketiled/i)
		{
			my @fn = sort glob("$INSTALLDIR/maps/$data");
			my $mins = $minscale;
			my $maxs = $maxscale;
			$maxs =~ s/[^0-9]//g;
			$mins =~ s/[^0-9]//g;
			my $step = ($maxs - $mins) / scalar @fn;


			Error "Cannot determine min and maxscale for layer $name" if ! $step;
			my @scale;
			for (my $size = $mins; $size <= $maxs; $size+= $step)
			{
				push @scale,$size;
			}

			@scale = reverse @scale;

			my $i = 0;
			foreach my $fn (@fn)
			{
				$fn =~ s/$INSTALLDIR\/maps\///;
				push @layers,
					"LAYER\n".
					"   NAME \"$name\"\n".
					"   # $notes\n".
    					"   DATA '$fn'\n".
    					"   STATUS $on\n".
    					"   TYPE  $type\n".
					"   MINSCALE ". (1+$scale[$i]) . "\n".
					"   MAXSCALE ".$scale[$i+1] . "\n" .
					$querymap.
					"\nEND # end of $name layer object\n";
				$i++;	
			}		
		}
		else
		{
			push @layers,
				"LAYER\n".
				"   NAME \"$name\"\n".
				"   # $notes\n".
    				"   DATA \"$data\"\n".
    				"   STATUS $on\n".
    				"   TYPE  $type\n".
				$minscale .
				$maxscale .
				$colour .
				$querymap.
				"\n$other\n".
				"END # end of $name layer object\n";
			}	
	}
	
	# OK NOW Create LAYERS based on data from institutions/sources
	my @datafiles = GrabLiveShapes($uniqueName);

	@datafiles = sort @datafiles;
	my @colourindex = (  
		'  0   0 255',
		'  0 255 255',
		'  0 255   0',
		'255 255   0',
		'255   0   0',
		'255   0 255',
		'  0   0 127',
		'  0 127 127',
		'  0 127   0',
		'127 127   0',
		'127   0   0',
		'127   0 127',
		'127   0 127',
		'127   0 127',
		'127   0 127',
		'127   0 127',
		'127   0 127',
	);	
	my $count = 0;

	my %dlayers;
	foreach my $datafile (@datafiles)
	{

		$datafile =~ s/\.shp$//;
		my $precision = $datafile;

		$precision =~ s/species(.*)_.+/$1/;
		if (! $precision)
		{
				$precision = 'other';
		}
		
		$count = 0 if $count >= scalar @{$conf{SYMBOL}};

		my ($shape,$size,$colour) = (${$conf{SYMBOL}}[$count],
					$conf{SYMBOLSIZE},
					$colourindex[$count]);
		$count++;

		# get name for each shapefile
		my $name = $datafile;

		my ($session,$filename,$description,$category,$portalLink) =
			perl::Tools::ReadInfoFile($name); 

		my $lcdescription = lc $description;

		my $count = '0';
		$count = $haveLatLong{$description} if exists $haveLatLong{$description};

		$description =~ s/:/ /g;

		#my $tolerance = int(2 * $conf{SYMBOLSIZE});
		my $tolerance = 10;


		my $layerDef = 
		"LAYER\n".
    		"   NAME '$lcdescription'\n".
		"   METADATA\n". 
		"	decription 'layer:$description'\n".
		"	CATEGORY '$category'\n".
		"	LINK '$portalLink&behaviour=standalone'\n".
		"	COUNT    '$count'\n".
		"   END\n".
		#"   PROJECTION\n".
		#"	geographic\n".
		#"   END\n".
    		"   DATA '$datafile'\n".
    		"   STATUS on\n".
    		"   TYPE  point\n".
		"   GROUP species\n".
    		"   CLASSITEM 'data'\n".
    		"   CLASS\n".
      		"   	SYMBOL '$shape' #MACRO normal(SYMBOL '$shape') alternate(SYMBOL 'querySymbol')\n".
      		"   	SIZE  $size #MACRO normal(SIZE $size) alternate(SIZE $size)\n".
      		"   	COLOR $colour #MACRO normal(COLOR $colour) alternate(COLOR 200 200 200)\n".
      		"   	NAME '$description'\n".
		"   	METADATA\n". 
		"		CATEGORY '$category'\n".
		"		COUNT    '$count'\n".
		"   	END\n".
    		"   END # end of class object\n".
    		"   HEADER '$INSTALLDIR/html/$conf{EMUCLIENT}/species_header.html'\n".
    		"   FOOTER '$INSTALLDIR/html/$conf{EMUCLIENT}/species_footer.html'\n".
		"   TEMPLATE '$INSTALLDIR/html/$conf{EMUCLIENT}/species.html'\n".
  		"   TOLERANCE $tolerance # tolerance = $tolerance pixels\n".
		"END\n";

		#push @dlayers,$layerDef;
		$dlayers{$lcdescription} = $layerDef;
	}
	foreach my $dlayer (sort {$b cmp $a} keys %dlayers)
	{
		push @layers,$dlayers{$dlayer};
	}

	my $LAYERS = join "\n", @layers;

	my $file;
	if (! -f $conf{MAP_TEMPLATE})
	{
		$file = ReadDefaultMapTemplate();
	}
	else
	{
		$file = perl::Tools::ReadTemplate($conf{MAP_TEMPLATE},"map Template");
	}



	
	# replace templated values
	$file =~ s/\[EXTENT\]/$conf{LATLONGEXTENT}/gi;
	$file =~ s/\[SIZE\]/$conf{MAPSIZE}/gi;
	$file =~ s/\[REFERENCEIMAGE\]/$conf{REFERENCE_IMAGE}/gi;
	$file =~ s/\[REFERENCEEXTENT\]/$conf{REFERENCELATLONGEXTENT}/gi;
	$file =~ s/\[MAPBITS\]/$INSTALLDIR/gi;
	$file =~ s/\[DISPFILE\]/$displayFile/gi;
	$file =~ s/\[LEGEND_TEMPLATE\]/$legendFile/gi;
	$file =~ s/\[TEMPDIR\]/$conf{TEMPDIR}/gi;
	$file =~ s/\[TEMPURL\]/$conf{TEMPURL}/gi;
	$file =~ s/\[LAYERS\]/$LAYERS/gi;
	$file =~ s/\[SESSION\]/$uniqueName/gi;
	$file =~ s/\[EMUCLIENT\]/$conf{EMUCLIENT}/gi;

	return  "MAP\nNAME '$uniqueName.map'\n".$file;
}

sub DisplayLinkPage($$)
{
	# returns data on a single record (called at users request
	# after selecting a record)

	my ($dataSource,$record) = @_;
	
	my ($xmlData,$error) = GetDataOnRecord($dataSource,$record);

	my $formattedData;

	if ($error)
	{
		$formattedData = $error;
	}
	else
	{
		if ($conf{XSL_DATA_VIEW}[0] and $conf{XSLTPROC})
		{
			my ($name,$onoff,$xss) = split /,/,$conf{XSL_DATA_VIEW}[0],3;
			$formattedData = perl::Tools::XsltTransform($xss,$xmlData,'');
		}
		else
		{
			$formattedData = perl::Tools::PrettyDisplayXML($xmlData);
		}
	}		

	$formattedData =~ s/^.*<body *.*?>//is;
	$formattedData =~ s/<\/body>.*?//is;

	my $file = perl::Tools::ReadTemplate($conf{RECORD_DISPLAY_HTML},"record display page");

	my $CLEAN_INTERVAL_MINS = $conf{CLEAN_INTERVAL} / 60;
	$file =~ s/\[STYLE\]/$conf{STYLE}/ig;
	$file =~ s/\[DATA\]/$formattedData/g;
	$file =~ s/\[SYSTEMNAME\]/$conf{SYSTEMNAME}/ig;
	$file =~ s/\[CONFIGURATION\]/$conf{CONF_DESCRIPTION}/i;
	$file =~ s/\[CLEAN_INTERVAL_MINS\]/$CLEAN_INTERVAL_MINS/ig;
	$file =~ s/\[RELEASE\]/$perl::Tools::WEBMAPRELEASE/i;
	return  "Content-type: text/html\n\n".$file;
	
}	
sub generalLinksPage($$)
{
	# builds a linkage page

	my ($name,$showby) = @_;
	$name =~ s/^\s+|\s+$//g;

	$name = '<h5>species searches not available when Data grouped by Source</h5>' if ( ($showby eq 'ke_source'));

	my ($genus,$subgenus,$species,$subspecies);
	if ($name =~ /^(\w+)\s+(\w+)\s+(\w+)$/)
	{
		$genus = $1;
		$species = $2;
		$subspecies = $2;
	}
	elsif ($name =~ /^(\w+)\s+(\w+)$/)
	{
		$genus = $1;
		$species = $2;
	}
	

	my $file = perl::Tools::ReadTemplate($conf{LINK_TEMPLATE},"link page");
	if (-e "$INSTALLDIR/$conf{LINK_LIST}")
	{
	
		# grab list of urls from list_template and assemble linkage details
		my @lines;
		open F,"$INSTALLDIR/$conf{LINK_LIST}" 
			or perl::Tools::Error("Could not open link list : $conf{LINK_LIST} : $!");
		while (my $line = <F>)
		{
			$line .= <F> while ($line =~ /\\\n*$/);
			$line =~ s/\\*\n//g;
			$line =~ s/#.*//;
			$line =~ s/^\s+//;
			if ($line)
			{
				my ($verbatim,$url) = split /~/,$line,2;
				if (! $url)
				{
					push @lines,$verbatim;
				}
				elsif ( !($showby eq 'ke_source'))
				{
					if ($line =~ /<digir>(.*)<\/digir>/)
					{
						my @args = split /~/,$1;
						my $args = "endpoint=$args[1]";
						$args .= "&resource=$args[2]";
						$args .= "&filter=$args[3]";
						$args .= "&start=$args[4]";
						$args .= "&number=$args[5]";
						$url = "$conf{CGIURL}?action=digir&$args";
					}
					if ($line =~ /\[NAME\]/i and ! $name)
					{
					}
					elsif ($line =~ /\[GENUS\]/i and ! $genus)
					{
					}
					elsif ($line =~ /\[SPECIES\]/i and ! $species)
					{
					}
					elsif ($verbatim =~ /(.*)<link>(.+)<\/link>(.*)/)
					{
						push @lines,"$1<a href='$url'>$2</a>$3";
					}
					else
					{
						push @lines,"<a href='$url'>$verbatim</a>";
					}
				}
			}
		}
		my $preferredMaxColLength = 14;
		my $maxCol = 3;
		# we want to lay data out in a reasonably viewable way
		# current algorithm - 
		# attempt to start new column if more than 'preferredMaxColLength' items
		# break into max of 'maxCol' columns 
		my $numCols = 1 + int(@lines / $preferredMaxColLength);
		$numCols = $maxCol if $numCols > $maxCol;
		my $maxColLength = (scalar @lines) / $numCols;
		my $links = '';
		for (my $i=0; $i < $maxColLength; $i++)
		{
			$links .= "\n<tr>\n\t";
			for (my $c=0; $c < $numCols; $c++)
			{
				my $item = $i+$c*(1+$maxColLength);
				if ($item < @lines)
				{
					$links .= "<td>" . $lines[$item] ."</td>";
				}
			}
			$links .= "\n</tr>\n";
		}
		$file =~ s/\[LINKS\]/<table class='small' border='0'>$links<\/table>/ig;
	}

	$file =~ s/\[NAME\]/$name/ig;
	$file =~ s/\[GENUS\]/$genus/ig;
	$file =~ s/\[SPECIES\]/$species/ig;
	$file =~ s/\[STYLE\]/$conf{STYLE}/ig;
	$file =~ s/\[RELEASE\]/$perl::Tools::WEBMAPRELEASE/i;
	$file =~ s/\[SYSTEMNAME\]/$conf{SYSTEMNAME}/gi;
	#$file =~ s/\[.*?\]//g;
	return  "Content-type: text/html\n\n".$file;
	
}	
sub ConfigurationReport()
{
	# displays details about system configuration

	my $clean = $conf{CLEAN_INTERVAL} / 60;
	my $HI = "<font color='2f7f2f'>";
	my $LO = "</font>";
	my @data;


	my $data = "Call the following URLS:<pre>\n".
		"======================================================\n";
	foreach my $name (sort @{$conf{URLS}})
	{
		my ($who,$on,$url,$proxy,$fields) = split /,/,$name;
		if ($proxy =~ /proxy/i)
		{
			$proxy = "\tUSE PROXY" if ($proxy =~ /proxy/i);
		}
		
		$data .= "$who\nSelected by Default is: $HI $on $LO\n".
			"URL $HI URL:$url\nPROXY:$proxy\nFIELDS:$fields $LO\n---------------------------\n";
	}
	push @data,"$data</pre>";

	$data = "The Following Shapefiles Are Available:<pre>\n";
	foreach my $shape (sort @{$conf{SHAPES}})
	{
		my ($name,$data,$type,$minscale,$maxscale,
			$colour,$on,$querymap,$other,$notes) 
			= split /,/,$shape,10;
		$data .= "NAME:$HI $name $LO\nFILE NAME:$HI $data $LO\n".
			"TYPE:$HI $type $LO\nVisible at Min Zoom:$HI $minscale $LO\n".
			"Visible at Max Zoom:$HI $maxscale $LO\n".
			"RGB Colours:$HI $colour $LO\n".
			"Notes:$HI $notes $LO\n".
			"Query Map is:$HI $querymap $LO\n".
			"On by Default is:$HI $on $LO\n-----------------------------\n";
	}
	push @data,"$data</pre>";

	$data = "<pre>Environment\n====================================================== \n";
	foreach my $param (sort keys %ENV)
	{
		$data .= "$param = $HI $ENV{$param} $LO\n";
	}
	#############################################################
	# Displays configuration
	$data .= "\nEMu Web Map System Configuration\n".
		 "====================================================== \n".
		 "Root of EMu Web Map system: $HI $INSTALLDIR $LO\n\n";

	foreach my $param (sort keys %conf)
	{
		$data .= "$param: $HI ";
		if (ref $conf{$param} eq 'ARRAY')
		{
			$data .= "<ol>\n";
			foreach my $item (@{$conf{$param}})
			{
				$data .=  "<li>$item</li>\n";
			}	
			$data .= "</ol>\n";
		}
		else
		{
			$conf{$param} =~ s/</&lt;/g;
			$conf{$param} =~ s/>/&gt;/g;
			$data .= $conf{$param};
		}
		$data .= "$LO\n";
	}
	$data .= " </pre>\n";
	push @data,$data;

	$data = join "\n",@data;
        if (exists $ENV{PATH_INFO})
	{
		$data = "Content-type: text/html\n\n".
	           "<html><body bgcolor='AfAfAf'>\n".
		   "<h2>Configuration</h2>\n$data</body></html>" ;
	}
	else
	{
		$data = "Configuration\n----------------------------\n$data";
	}

	return $data;
}

sub ShowEnvironment($%)
{
	my ($cgistring,%param) = @_;

	my $HI = "<font color='7fff7f'>";
	my $LO = "</font>";

	my $data .= "SYSTEM: $conf{SYSTEMNAME} <pre>\n================================== \n";
	$data .= "cgi string called with: $HI $CGIstring $LO\n";
	$data .= "cgi string calling mapserver with: $HI $cgistring $LO\n";

	$data .= "Parameters Extracted:\n";
	foreach my $param (sort keys %param)
	{
		$data .= "$param = $HI $param{$param} $LO\n";
	}

	$data .= "<pre>Environment\n================================== \n";

	foreach my $param (sort keys %ENV)
	{
		$data .= "$param = $HI $ENV{$param} $LO\n";
	}
	#############################################################
	# Displays configuration
	$data .= "\n$conf{SYSTEMNAME} System Configuration\n".
		 "====================================================== \n".
		 "Root of $conf{SYSTEMNAME} system: $HI $INSTALLDIR $LO\n\n";

	foreach my $param (sort keys %conf)
	{
		$data .= "$param: $HI ";
		if (ref $conf{$param} eq 'ARRAY')
		{
			$data .= "<ol>\n";
			foreach my $item (@{$conf{$param}})
			{
				$data .=  "<li>$item</li>\n";
			}	
			$data .= "</ol>\n";
		}
		else
		{
			$conf{$param} =~ s/</&lt;/g;
			$conf{$param} =~ s/>/&gt;/g;
			$data .= $conf{$param};
		}
		$data .= "$LO\n";
	}
	$data .= " </pre>\n";

	return $data;
}
